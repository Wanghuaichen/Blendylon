// Generated by CoffeeScript 1.12.2
var Animation, Easing, Timeline, TimelineGui;

TimelineGui = require('./timeline.gui');

Animation = require('./Animation');

Easing = require('./easing');

Timeline = (function() {
  Timeline.prototype.name = 'Global';

  Timeline.prototype.animations = [];

  Timeline.prototype.totalTime = 0;

  Timeline.prototype.loopCount = 0;

  Timeline.prototype.loopMode = 0;

  Timeline.prototype.interval = 0;

  Timeline.prototype.reversed = false;

  Timeline.prototype.playing = false;

  Timeline.prototype.fps = 60;

  function Timeline(container) {
    this.time = 0;
    this.gui = new TimelineGui(container, this);
    this.interval = setInterval((function(_this) {
      return function() {
        _this.update();
        _this.gui.time = _this.time;
        return _this.gui.update();
      };
    })(this), 1000 / this.fps);
  }

  Timeline.prototype.play = function(reversed) {
    if (reversed == null) {
      reversed = false;
    }
    this.playing = true;
    return this.reversed = reversed;
  };

  Timeline.prototype.pause = function() {
    return this.playing = false;
  };

  Timeline.prototype.stop = function() {
    this.playing = false;
    return this.time = 0;
  };

  Timeline.prototype.goToStart = function() {
    return this.time = 0;
  };

  Timeline.prototype.goToEnd = function() {
    return this.time = this.findAnimationEnd();
  };

  Timeline.prototype.findAnimationEnd = function() {
    var endTime, i;
    endTime = 60;
    i = 0;
    while (i < this.animations.length) {
      if (this.animations[i].endTime > endTime) {
        endTime = this.animations[i].endTime;
      }
      i++;
    }
    return endTime;
  };

  Timeline.prototype.applyValues = function() {
    var duration, i, properties, startValue, t, value;
    i = 0;
    while (i < this.animations.length) {
      properties = this.animations[i];
      if (this.time < properties.startTime || properties.hasEnded) {
        i++;
        continue;
      }
      if (this.time >= properties.startTime && !properties.hasStarted) {
        startValue = properties.target[properties.propertyName];
        if (startValue.length && startValue.indexOf('px') > -1) {
          properties.startValue = Number(startValue.replace('px', ''));
          properties.unit = 'px';
        } else {
          properties.startValue = Number(startValue);
        }
        properties.hasStarted = true;
        if (properties.onStart) {
          properties.onStart();
        }
      }
      duration = properties.endTime - properties.startTime;
      t = duration ? (this.time - properties.startTime) / duration : 1;
      t = Math.max(0, Math.min(t, 1));
      t = properties.easing(t);
      value = properties.startValue + (properties.endValue - properties.startValue) * t;
      if (properties.unit) {
        value += properties.unit;
      }
      properties.target[properties.propertyName] = value;
      if (properties.parent && properties.parent.onUpdateCallback) {
        properties.parent.onUpdateCallback(properties);
      }
      if (this.time >= properties.endTime && !properties.hasEnded) {
        properties.hasEnded = true;
        if (properties.onEnd) {
          properties.onEnd();
        }
      }
      if (t === 1) {
        if (this.loopMode === 0) {
          this.animations.splice(i, 1);
          i--;
        }
      }
      i++;
    }
  };

  Timeline.prototype.update = function(deltaTime) {
    var animationEnd, i;
    if (typeof deltaTime !== 'undefined') {
      if (this.loopInterval !== 0) {
        clearInterval(this.loopInterval);
        this.loopInterval = 0;
      }
    } else {
      deltaTime = 1 / this.fps;
    }
    if (this.playing) {
      if (!this.reversed) {
        this.totalTime += deltaTime;
      }
      if (!this.reversed) {
        this.time += deltaTime;
      }
      if (this.reversed) {
        this.totalTime -= deltaTime;
      }
      if (this.reversed) {
        this.time -= deltaTime;
      }
    }
    if (this.loopMode !== 0) {
      animationEnd = this.findAnimationEnd();
      if (this.time > animationEnd) {
        if (this.loopMode === -1 || this.loopCount < this.loopMode) {
          this.time = 0;
          this.loopCount++;
          i = 0;
          while (i < this.anims.length) {
            this.animations[i].hasStarted = false;
            this.animations[i].hasEnded = false;
            i++;
          }
        } else {
          this.playing = false;
          this.time = 0;
        }
      }
      if (this.time < 0) {
        this.time = animationEnd;
      }
    }
    return this.applyValues();
  };

  return Timeline;

})();

module.exports = Timeline;

//# sourceMappingURL=timeline.js.map
