// Generated by CoffeeScript 1.12.2
var Animation, Easing;

Easing = require('./easing');

Animation = (function() {
  Animation.startTime = 0;

  Animation.endTime = 0;

  Animation.time = 0;

  Animation.properties = [];

  Animation.groups = [];

  Animation.started = false;

  Animation.ended = false;

  function Animation(name, target, timeline) {
    this.name = name;
    this.target = target;
    this.timeline = timeline;
  }

  Animation.prototype.to = function() {
    var animInfo, args, delay, duration, easing, group, i, nop, properties, propertyName;
    args = [];
    i = 0;
    while (i < arguments.length) {
      args.push(arguments[i]);
      i++;
    }
    delay = void 0;
    properties = void 0;
    duration = void 0;
    easing = void 0;
    delay = typeof args[0] === 'number' ? args.shift() : 0;
    properties = typeof args[0] === 'object' ? args.shift() : {};
    duration = typeof args[0] === 'number' ? args.shift() : 1;
    easing = typeof args[0] === 'function' ? args.shift() : Easing.Linear.EaseNone;
    group = [];
    nop = function() {};
    for (propertyName in properties) {
      animInfo = {
        hasStarted: false,
        timeline: this.timeline,
        targetName: this.name,
        target: this.target,
        propertyName: propertyName,
        endValue: properties[propertyName],
        delay: delay,
        startTime: this.timeline.time + delay + this.endTime,
        endTime: this.timeline.time + delay + this.endTime + duration,
        easing: easing,
        parent: this,
        onStart: nop,
        onEnd: nop
      };
      this.timeline.anims.push(animInfo);
      group.push(animInfo);
    }
    this.groups.push(group);
    this.endTime += delay + duration;
    return this;
  };

  Animation.prototype.onStart = function(callback) {
    var called, currentGroup;
    currentGroup = this.groups[this.groups.length - 1];
    if (!currentGroup) {
      return;
    }
    called = false;
    currentGroup.forEach(function(animation) {
      animation.onStart = function() {
        if (!called) {
          called = true;
          callback();
        }
      };
    });
    return this;
  };

  Animation.prototype.onUpdate = function(callback) {
    this.onUpdateCallback = (function(_this) {
      return function() {
        callback();
      };
    })(this);
    return this;
  };

  Animation.prototype.onEnd = function(callback) {
    var called, currentGroup;
    currentGroup = this.groups[this.groups.length - 1];
    if (!currentGroup) {
      return;
    }
    called = false;
    currentGroup.forEach(function(animation) {
      animation.onEnd = function() {
        if (!called) {
          called = true;
          callback();
        }
      };
    });
    return this;
  };

  return Animation;

})();

module.exports = Animation;

//# sourceMappingURL=Animation.js.map
